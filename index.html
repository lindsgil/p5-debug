<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta charset="utf-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.0.0/p5.min.js"></script>
    <script>
        let tokenData = {"tokenId":"1000000","hash":"0xd4fbd67f2a18cfe4f619512598bd01722435341067f2e309784179b7e6eccd86"}
    </script>
    <script>
      class Random{constructor(){this.useA=!1;let n=function(n){let t=parseInt(n.substring(0,8),16),e=parseInt(n.substring(8,16),16),o=parseInt(n.substring(16,24),16),a=parseInt(n.substring(24,32),16);return function(){t|=0,e|=0,o|=0,a|=0;let n=(t+e|0)+a|0;return a=a+1|0,t=e^e>>>9,e=o+(o<<3)|0,o=o<<21|o>>>11,o=o+n|0,(n>>>0)/4294967296}};this.prngA=new n(tokenData.hash.substring(2,34)),this.prngB=new n(tokenData.hash.substring(34,66));for(let n=0;n<1e6;n+=2)this.prngA(),this.prngB()}random_dec(){return this.useA=!this.useA,this.useA?this.prngA():this.prngB()}random_num(n,t){return n+(t-n)*this.random_dec()}random_int(n,t){return Math.floor(this.random_num(n,t+1))}random_bool(n){return this.random_dec()<n}random_choice(n){return n[this.random_int(0,n.length-1)]}}let R=new Random;minFiles=0,maxFiles=0;const SEED=R.random_int(minFiles,maxFiles);console.log(`Selection: ${SEED}`);var _00=function(){function n(n,t=1.1,e=1){return t*e/(e-n*(e-t))}function t(n,t){for(let e=0;e<r.length;e++)n.setUniform(r[e],m[t][e])}function e(n,t){for(let[e,o]of Object.entries(w[t]))n.setUniform(e,o)}function o(n=0,t=1){let e=(t-n)*R.random_dec()+n;return e}function a(n){return n[Math.floor(o()*n.length)]}function c(n){return n.reduce((n,t,e,o)=>{const a=o.slice(0,e+1),i=a.reduce((n,t)=>n+t,0);return[...n,i]},[])}function l(){const n=p5.RendererGL.prototype._initContext;p5.RendererGL.prototype._initContext=function(){this.drawingContext=this.canvas.getContext("webgl2",{alpha:!0,depth:!0,stencil:!0,antialias:!0,premultipliedAlpha:!0,preserveDrawingBuffer:!1,failIfMajorPerformanceCaveat:!0}),this.drawingContext?console.log("WebGL 2.0 context successfully created."):(console.warn("WebGL 2.0 is not supported by your browser. Falling back to WebGL 1.0."),n.call(this))}}this.seed=SEED,l();let r=["LF1","LF2","LR1","LR2","dA1","dA2","df1","df2","wb1","wb2","bb1","bb2","Nf1","Nf2","Nn1","Nn2","Nx1","Nx2","indx","Ld","cBlend"],m=[],h={seed:o(-1e3,1e3),mult1:o(2,18),mult2:o(5,12),horizon:.1,hengeHighlight:1e3,shadowStrength:6,ground:.5,lineWeightMult:1,clear:2,night:2};const f="#version 300 es\n in vec3 aPosition;\n in vec2 aTexCoord;\n out vec2 vTexCoord;\n void main() { \n vTexCoord = aTexCoord;\n vTexCoord.x *= 9./16.;\n vec4 positionVec4 = vec4(aPosition, 1.0);\n positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n gl_Position = positionVec4;\n }\n ",u="#version 300 es // Author:Jesse Bassett\nprecision highp float;\nin vec2 vTexCoord;\nout vec4 fragColor ; uniform vec4 LF1; uniform vec2 LF2; uniform vec4 LR1; uniform vec2 LR2; uniform vec4 dA1; uniform vec2 dA2; uniform vec4 df1; uniform vec2 df2; uniform vec4 wb1; uniform vec2 wb2; uniform vec4 bb1; uniform vec2 bb2; uniform vec4 Nf1; uniform vec2 Nf2; uniform vec4 Nn1; uniform vec2 Nn2; uniform vec4 Nx1; uniform vec2 Nx2; uniform float indx; uniform vec4 Ld; uniform float cBlend; uniform float cloudSeed; uniform float N1; uniform float N2; uniform float horizon; uniform float ground; uniform float clear; uniform float night; uniform vec2 rez; uniform float isBase; uniform vec2 v1U; uniform vec2 v2U; uniform float thU; uniform float r1U; uniform float r2U;\nconst int Len = 5;\nint sel = 2;\nfloat time = -0.04;\nconst int N_Octaves = 8;\n#define BlendScreen(base, blend) (1.0 - ((1.0 - base) * (1.0 - blend)))\nuint pcg(uint v) {\n\tuint state = v * uint(747796405) + uint(2891336453);\n\tuint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n\treturn (word >> uint(22)) ^ word;\n}\nfloat prng (float p) {\n\treturn float(pcg(uint(p))) / float(uint(0xffffffff));\n}\nfloat prng (vec2 p) {\n\treturn float(pcg(pcg(uint(p.x)) + uint(p.y))) / float(uint(0xffffffff));\n}\nfloat prng (vec3 p) {\n\treturn float(pcg(pcg(uint(p.x)) + uint(p.y) + uint(p.z))) / float(uint(0xffffffff));\n}\nfloat prng (vec4 p) {\n\treturn float(pcg(pcg(uint(p.x)) + uint(p.y) + uint(p.z) + uint(p.w))) / float(uint(0xffffffff));\n}\nfloat snoise(vec2 v) {\n const vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n vec2 i = floor(v + dot(v, C.yy));\n vec2 x0 = v - i + dot(i, C.xx);\n vec2 i1;\n i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n vec2 x1 = x0.xy + C.xx - i1;\n vec2 x2 = x0.xy + C.zz;\n float n0 = prng(vec3(i, 0.0));\n float n1 = prng(vec3(i + i1, 1.0));\n float n2 = prng(vec3(i + vec2(1.0), 2.0));\n vec3 x = vec3(n0, n1, n2) * 2.0 - 1.0;\n vec3 h = abs(x) - 0.5;\n vec3 ox = floor(x + 0.5);\n vec3 a0 = x - ox;\n vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n m = m * m;\n m = m * m;\n a0 = vec3(n0, n1 - n0, n2 - n0); \n vec3 g;\n g.x = a0.x * x0.x + h.x * x0.y;\n g.yz = a0.yz * vec2(x1.x, x2.x) + h.yz * vec2(x1.y, x2.y);\n return 130.0 * dot(m, g);\n}\nfloat noise3d(vec3 p){\n vec3 a = floor(p);\n vec3 d = p - a;\n d = d * d * (3.0 - 2.0 * d);\n float n000 = prng(a + vec3(0.0, 0.0, 0.0));\n float n100 = prng(a + vec3(1.0, 0.0, 0.0));\n float n010 = prng(a + vec3(0.0, 1.0, 0.0));\n float n110 = prng(a + vec3(1.0, 1.0, 0.0));\n float n001 = prng(a + vec3(0.0, 0.0, 1.0));\n float n101 = prng(a + vec3(1.0, 0.0, 1.0));\n float n011 = prng(a + vec3(0.0, 1.0, 1.0));\n float n111 = prng(a + vec3(1.0, 1.0, 1.0));\n float n00 = mix(n000, n100, d.x);\n float n10 = mix(n010, n110, d.x);\n float n01 = mix(n001, n101, d.x);\n float n11 = mix(n011, n111, d.x);\n float n0 = mix(n00, n10, d.y);\n float n1 = mix(n01, n11, d.y);\n float n = mix(n0, n1, d.z);\n return n;\n}\nvec2 rotateUV(vec2 uv, float rotation){ \n float rotation2 = rotation * (isBase+1.) * 0.261799 * 2.;\n return vec2( \n cos(rotation2) * (uv.x - 0.5) + sin(rotation2) * (uv.y - 0.5) + 0.5, \n cos(rotation2) * (uv.y - 0.5) - sin(rotation2) * (uv.x - 0.5) + 0.5\n ); \n}\nfloat SmoothStep( float edge0, float edge1,float x ){\n float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n return t;\n}\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n float l = length(b-a);\n vec2 d = (b-a)/l;\n vec2 q = p-(a+b)*0.5;\n q = mat2(d.x,-d.y,d.y,d.x)*q;\n q = abs(q)-vec2(l*0.5,th);\n return length(max(q,0.0)) + min(max(q.x,q.y),0.0); \n}\nvec4 shadeCloud(vec2 v1,vec2 v2,float th,float r){\n vec4 R = vec4(0.0);\n vec2 V = v2-v1;\n V = V.yx;\n V.x= -V.x*sign(r);\n V.y= V.y*sign(r);\n r=abs(r);\n V = normalize(V)*(th-th*r);\n R.xy = v1 + V;\n R.yw = v2 + V;\n R.x = v1.x + V.x;\n R.y = v1.y + V.y;\n R.z = v2.x + V.x;\n R.w = v2.y + V.y;\n return R;\n}\nvec3 col3d ( in vec3 P, in vec2 st, in vec2 v1, in vec2 v2, in float th, in float r, in float r2) {\n vec3 x = P * N1 ;\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < N_Octaves; ++i) {\n\t\tv += a * noise3d(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n st += vec2(v)*N2*(sin(time));\n vec4 SH;\n vec3 c;\n float mask1 = sdOrientedBox( st, v1, v2, th );\n mask1 = 0.0 + sign(mask1)*1.;\n SH = shadeCloud(v1,v2,th,abs(r));\n float mask2 = sdOrientedBox( st, SH.xy, SH.zw, th*r );\n mask2 = 0.0 + sign(mask2)*1.; \n SH = shadeCloud(v1,v2,th,-r2);\n float mask3 = sdOrientedBox( st, SH.xy, SH.zw, th*r2 );\n mask3 = 0.0 + sign(mask3)*1.;\n c = vec3(mask1,mask2,mask3);\n return c;\n}\nvec2 OP( vec2 st, float r, float w, float d, float s, float ww , float b, float n, float N, float X){ // from #3\n st = rotateUV(st,r);\n st.x += cos(st.y*w)/d;\n st.y += sin(st.x*w)/d;\n float pos = st.x * s;\n float L = ww*b*( (cos(pos*2.*3.14)+1.)/2. )-b+1.;\n float colLC = clamp(L,0.090,1.0);\n vec2 p = st * n;\n float colN = (snoise(p)*.5+.5);\n float colNC = smoothstep(N,X,colN);\n return vec2 ( colNC, colLC );\n}\nvoid main() {\n vec3 DEBUG = vec3(0.);\n vec2 st = vTexCoord;\n vec3 param = vec3(0.);\n vec3 C;\n vec3 aCheck = vec3(0.0);\n vec2 v1 = v1U;\n vec2 v2 = v2U;\n float th = thU;\n float r = r1U;\n float r2 = r2U;\n float a = 1.352;\n if(isBase >= 1.){\n a = 1.;\n }\n float th_o = th;\n r = a*r;\n th += (a-1.)*r;\n r2 = (th_o*r2)/(th);\n v1.y += (a-1.)*r;\n v2.y += (a-1.)*r;\n v1.y = -2.*((horizon+0.1)*v1.y-(horizon+0.1)-v1.y+0.5);\n v2.y = -2.*((horizon+0.1)*v2.y-(horizon+0.1)-v2.y+0.5);\n C = col3d( vec3( st.x, st.y, cloudSeed), st, v1, v2, th, r, r2 );\n DEBUG = vec3(C);\n aCheck = C;\n float mask1 = C.x;\n float mask2 = C.y;\n float mask3 = C.z;\n vec2 st_1 = st;\n vec2 st_2 = st;\n vec2 st_3 = st;\n vec2 st_4 = st;\n vec2 st_5 = st;\n vec2 st_6 = st;\n vec3 color = vec3(0.0);\n st_1 = rotateUV(st,LR1.x );\n st_1.x += cos(st_1.y*dA1.x)/df1.x;\n st_1.y += sin(st_1.x*dA1.x)/df1.x;\n float pos_1 = st_1.x * LF1.x;\n float y = 0.;\n float x = pos_1;\n y = sin( (x+Ld.z) *Ld.y);\n y += sin( (x+Ld.z) *Ld.y*2.1 + Ld.w)*4.5;\n y += sin( (x+Ld.z) *Ld.y*1.72 + Ld.w*1.121)*4.0;\n y += sin( (x+Ld.z) *Ld.y*2.221 + Ld.w*0.437)*5.0;\n y += sin( (x+Ld.z) *Ld.y*3.1122+ Ld.w*4.269)*2.5;\n y *= Ld.x*0.06;\n pos_1 = pos_1+y;\n float colL_1 = wb1.x*bb1.x*( (cos(pos_1*2.*3.14)+1.)/2. )-bb1.x+1.;\n float colLC_1 = clamp(colL_1,0.090,1.0);\n vec2 posN_1 = st * Nf1.x;\n float colN_1 = (snoise(posN_1)*.5+.5);\n float colNC_1 = smoothstep(Nn1.x,Nx1.x,colN_1);\n st_2 = rotateUV(st_2,LR1.y);\n st_2.x += cos(st_2.y*dA1.y)/df1.y;\n st_2.y += sin(st_2.x*dA1.y)/df1.y;\n float pos_2 = st_2.x * LF1.y;\n float colL_2 = wb1.y*bb1.y*( (cos(pos_2*2.*3.14)+1.)/2. )-bb1.y+1.;\n float colLC_2 = clamp(colL_2,0.090,1.0);\n vec2 posN_2 = st_2 * Nf1.y;\n float colN_2 = (snoise(posN_2)*.5+.5);\n float colNC_2 = smoothstep(Nn1.y,Nx1.y,colN_2);\n vec2 temp3 = OP(st_3,LR1.z,dA1.z,df1.z,LF1.z,wb1.z,bb1.z,Nf1.z,Nn1.z,Nx1.z); \n float colLC_3 = temp3.x;\n float colNC_3 = temp3.y;\n vec2 temp4 = OP(st_4,LR1.w,dA1.w,df1.w,LF1.w,wb1.w,bb1.w,Nf1.w,Nn1.w,Nx1.w); \n float colLC_4 = temp4.x;\n float colNC_4 = temp4.y;\n vec2 temp5 = OP(st_5,LR2.x,dA2.x,df2.x,LF2.x,wb2.x,bb2.x,Nf2.x,Nn2.x,Nx2.x); \n float colLC_5 = temp5.x;\n float colNC_5 = temp5.y;\n vec2 posN_6 = st_6 * Nf2.y;\n float colN_6 = (snoise(posN_6)*.5+.5);\n float colNC_6 = smoothstep(Nn2.y,Nx2.y,colN_6);\n if(isBase >= 1.){\n colNC_1 = -colNC_1+1.0;\n colNC_1 = colNC_1*(C.x);\n colNC_1 = -co…
    </script>
    <style type="text/css">
        html {
            height: 100%;
        }
        body {
            min-height: 100%;
            margin: 0;
            padding: 0;
        }
        canvas {
            padding: 0;
            margin: auto;
            display: block;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
    </style>
</head>
<body>
</body>
</html>
